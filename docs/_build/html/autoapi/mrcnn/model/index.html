<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mrcnn.model &mdash; OL_mrcnn 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=eafc0fe6" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=8d563738"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            OL_mrcnn
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mrcnn.model</span></code></a><ul>
<li><a class="reference internal" href="#module-contents">Module Contents</a><ul>
<li><a class="reference internal" href="#classes">Classes</a></li>
<li><a class="reference internal" href="#functions">Functions</a><ul>
<li><a class="reference internal" href="#mrcnn.model.log"><code class="docutils literal notranslate"><span class="pre">log()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.BatchNorm"><code class="docutils literal notranslate"><span class="pre">BatchNorm</span></code></a><ul>
<li><a class="reference internal" href="#mrcnn.model.BatchNorm.call"><code class="docutils literal notranslate"><span class="pre">BatchNorm.call()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mrcnn.model.compute_backbone_shapes"><code class="docutils literal notranslate"><span class="pre">compute_backbone_shapes()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.identity_block"><code class="docutils literal notranslate"><span class="pre">identity_block()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.conv_block"><code class="docutils literal notranslate"><span class="pre">conv_block()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.resnet_graph"><code class="docutils literal notranslate"><span class="pre">resnet_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.apply_box_deltas_graph"><code class="docutils literal notranslate"><span class="pre">apply_box_deltas_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.clip_boxes_graph"><code class="docutils literal notranslate"><span class="pre">clip_boxes_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.ProposalLayer"><code class="docutils literal notranslate"><span class="pre">ProposalLayer</span></code></a><ul>
<li><a class="reference internal" href="#mrcnn.model.ProposalLayer.get_config"><code class="docutils literal notranslate"><span class="pre">ProposalLayer.get_config()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.ProposalLayer.call"><code class="docutils literal notranslate"><span class="pre">ProposalLayer.call()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.ProposalLayer.compute_output_shape"><code class="docutils literal notranslate"><span class="pre">ProposalLayer.compute_output_shape()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mrcnn.model.log2_graph"><code class="docutils literal notranslate"><span class="pre">log2_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.PyramidROIAlign"><code class="docutils literal notranslate"><span class="pre">PyramidROIAlign</span></code></a><ul>
<li><a class="reference internal" href="#mrcnn.model.PyramidROIAlign.get_config"><code class="docutils literal notranslate"><span class="pre">PyramidROIAlign.get_config()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.PyramidROIAlign.call"><code class="docutils literal notranslate"><span class="pre">PyramidROIAlign.call()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.PyramidROIAlign.compute_output_shape"><code class="docutils literal notranslate"><span class="pre">PyramidROIAlign.compute_output_shape()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mrcnn.model.overlaps_graph"><code class="docutils literal notranslate"><span class="pre">overlaps_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.detection_targets_graph"><code class="docutils literal notranslate"><span class="pre">detection_targets_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.DetectionTargetLayer"><code class="docutils literal notranslate"><span class="pre">DetectionTargetLayer</span></code></a><ul>
<li><a class="reference internal" href="#mrcnn.model.DetectionTargetLayer.get_config"><code class="docutils literal notranslate"><span class="pre">DetectionTargetLayer.get_config()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.DetectionTargetLayer.call"><code class="docutils literal notranslate"><span class="pre">DetectionTargetLayer.call()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.DetectionTargetLayer.compute_output_shape"><code class="docutils literal notranslate"><span class="pre">DetectionTargetLayer.compute_output_shape()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.DetectionTargetLayer.compute_mask"><code class="docutils literal notranslate"><span class="pre">DetectionTargetLayer.compute_mask()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mrcnn.model.refine_detections_graph"><code class="docutils literal notranslate"><span class="pre">refine_detections_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.DetectionLayer"><code class="docutils literal notranslate"><span class="pre">DetectionLayer</span></code></a><ul>
<li><a class="reference internal" href="#mrcnn.model.DetectionLayer.get_config"><code class="docutils literal notranslate"><span class="pre">DetectionLayer.get_config()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.DetectionLayer.call"><code class="docutils literal notranslate"><span class="pre">DetectionLayer.call()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.DetectionLayer.compute_output_shape"><code class="docutils literal notranslate"><span class="pre">DetectionLayer.compute_output_shape()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mrcnn.model.rpn_graph"><code class="docutils literal notranslate"><span class="pre">rpn_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.build_rpn_model"><code class="docutils literal notranslate"><span class="pre">build_rpn_model()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.fpn_classifier_graph"><code class="docutils literal notranslate"><span class="pre">fpn_classifier_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.build_fpn_mask_graph"><code class="docutils literal notranslate"><span class="pre">build_fpn_mask_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.smooth_l1_loss"><code class="docutils literal notranslate"><span class="pre">smooth_l1_loss()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.rpn_class_loss_graph"><code class="docutils literal notranslate"><span class="pre">rpn_class_loss_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.rpn_bbox_loss_graph"><code class="docutils literal notranslate"><span class="pre">rpn_bbox_loss_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.mrcnn_class_loss_graph"><code class="docutils literal notranslate"><span class="pre">mrcnn_class_loss_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.mrcnn_bbox_loss_graph"><code class="docutils literal notranslate"><span class="pre">mrcnn_bbox_loss_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.mrcnn_mask_loss_graph"><code class="docutils literal notranslate"><span class="pre">mrcnn_mask_loss_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.load_image_gt"><code class="docutils literal notranslate"><span class="pre">load_image_gt()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.build_detection_targets"><code class="docutils literal notranslate"><span class="pre">build_detection_targets()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.build_rpn_targets"><code class="docutils literal notranslate"><span class="pre">build_rpn_targets()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.generate_random_rois"><code class="docutils literal notranslate"><span class="pre">generate_random_rois()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.DataGenerator"><code class="docutils literal notranslate"><span class="pre">DataGenerator</span></code></a><ul>
<li><a class="reference internal" href="#mrcnn.model.DataGenerator.__len__"><code class="docutils literal notranslate"><span class="pre">DataGenerator.__len__()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.DataGenerator.__getitem__"><code class="docutils literal notranslate"><span class="pre">DataGenerator.__getitem__()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN"><code class="docutils literal notranslate"><span class="pre">MaskRCNN</span></code></a><ul>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.build"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.build()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.find_last"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.find_last()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.load_weights"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.load_weights()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.get_imagenet_weights"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.get_imagenet_weights()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.compile"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.compile()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.set_trainable"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.set_trainable()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.set_log_dir"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.set_log_dir()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.train"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.train()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.mold_inputs"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.mold_inputs()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.unmold_detections"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.unmold_detections()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.detect"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.detect()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.detect_molded"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.detect_molded()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.get_anchors"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.get_anchors()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.ancestor"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.ancestor()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.find_trainable_layer"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.find_trainable_layer()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.get_trainable_layers"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.get_trainable_layers()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.MaskRCNN.run_graph"><code class="docutils literal notranslate"><span class="pre">MaskRCNN.run_graph()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mrcnn.model.compose_image_meta"><code class="docutils literal notranslate"><span class="pre">compose_image_meta()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.parse_image_meta"><code class="docutils literal notranslate"><span class="pre">parse_image_meta()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.parse_image_meta_graph"><code class="docutils literal notranslate"><span class="pre">parse_image_meta_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.mold_image"><code class="docutils literal notranslate"><span class="pre">mold_image()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.unmold_image"><code class="docutils literal notranslate"><span class="pre">unmold_image()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.trim_zeros_graph"><code class="docutils literal notranslate"><span class="pre">trim_zeros_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.batch_pack_graph"><code class="docutils literal notranslate"><span class="pre">batch_pack_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.norm_boxes_graph"><code class="docutils literal notranslate"><span class="pre">norm_boxes_graph()</span></code></a></li>
<li><a class="reference internal" href="#mrcnn.model.denorm_boxes_graph"><code class="docutils literal notranslate"><span class="pre">denorm_boxes_graph()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">OL_mrcnn</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mrcnn.model</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/autoapi/mrcnn/model/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-mrcnn.model">
<span id="mrcnn-model"></span><h1><a class="reference internal" href="#module-mrcnn.model" title="mrcnn.model"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mrcnn.model</span></code></a><a class="headerlink" href="#module-mrcnn.model" title="Link to this heading"></a></h1>
<p>Mask R-CNN
The main Mask R-CNN model implementation.</p>
<p>Copyright (c) 2017 Matterport, Inc.
Licensed under the MIT License (see LICENSE for details)
Written by Waleed Abdulla</p>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Link to this heading"></a></h2>
<section id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h3>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.BatchNorm" title="mrcnn.model.BatchNorm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BatchNorm</span></code></a></p></td>
<td><p>Extends the Keras BatchNormalization class to allow a central place</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.ProposalLayer" title="mrcnn.model.ProposalLayer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProposalLayer</span></code></a></p></td>
<td><p>Receives anchor scores and selects a subset to pass as proposals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.PyramidROIAlign" title="mrcnn.model.PyramidROIAlign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PyramidROIAlign</span></code></a></p></td>
<td><p>Implements ROI Pooling on multiple levels of the feature pyramid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.DetectionTargetLayer" title="mrcnn.model.DetectionTargetLayer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DetectionTargetLayer</span></code></a></p></td>
<td><p>Subsamples proposals and generates target box refinement, class_ids,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.DetectionLayer" title="mrcnn.model.DetectionLayer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DetectionLayer</span></code></a></p></td>
<td><p>Takes classified proposal boxes and their bounding box deltas and</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.DataGenerator" title="mrcnn.model.DataGenerator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataGenerator</span></code></a></p></td>
<td><p>An iterable that returns images and corresponding target class ids,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.MaskRCNN" title="mrcnn.model.MaskRCNN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MaskRCNN</span></code></a></p></td>
<td><p>Encapsulates the Mask RCNN model functionality.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h3>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.log" title="mrcnn.model.log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log</span></code></a>(text[, array])</p></td>
<td><p>Prints a text message. And, optionally, if a Numpy array is provided it</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.compute_backbone_shapes" title="mrcnn.model.compute_backbone_shapes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_backbone_shapes</span></code></a>(config, image_shape)</p></td>
<td><p>Computes the width and height of each stage of the backbone network.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.identity_block" title="mrcnn.model.identity_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">identity_block</span></code></a>(input_tensor, kernel_size, filters, ...)</p></td>
<td><p>The identity_block is the block that has no conv layer at shortcut</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.conv_block" title="mrcnn.model.conv_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conv_block</span></code></a>(input_tensor, kernel_size, filters, stage, ...)</p></td>
<td><p>conv_block is the block that has a conv layer at shortcut</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.resnet_graph" title="mrcnn.model.resnet_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resnet_graph</span></code></a>(input_image, architecture[, stage5, train_bn])</p></td>
<td><p>Build a ResNet graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.apply_box_deltas_graph" title="mrcnn.model.apply_box_deltas_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_box_deltas_graph</span></code></a>(boxes, deltas)</p></td>
<td><p>Applies the given deltas to the given boxes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.clip_boxes_graph" title="mrcnn.model.clip_boxes_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip_boxes_graph</span></code></a>(boxes, window)</p></td>
<td><p>boxes: [N, (y1, x1, y2, x2)]</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.log2_graph" title="mrcnn.model.log2_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log2_graph</span></code></a>(x)</p></td>
<td><p>Implementation of Log2. TF doesn't have a native implementation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.overlaps_graph" title="mrcnn.model.overlaps_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlaps_graph</span></code></a>(boxes1, boxes2)</p></td>
<td><p>Computes IoU overlaps between two sets of boxes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.detection_targets_graph" title="mrcnn.model.detection_targets_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detection_targets_graph</span></code></a>(proposals, gt_class_ids, ...)</p></td>
<td><p>Generates detection targets for one image. Subsamples proposals and</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.refine_detections_graph" title="mrcnn.model.refine_detections_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">refine_detections_graph</span></code></a>(rois, probs, deltas, window, ...)</p></td>
<td><p>Refine classified proposals and filter overlaps and return final</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.rpn_graph" title="mrcnn.model.rpn_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rpn_graph</span></code></a>(feature_map, anchors_per_location, anchor_stride)</p></td>
<td><p>Builds the computation graph of Region Proposal Network.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.build_rpn_model" title="mrcnn.model.build_rpn_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_rpn_model</span></code></a>(anchor_stride, anchors_per_location, depth)</p></td>
<td><p>Builds a Keras model of the Region Proposal Network.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.fpn_classifier_graph" title="mrcnn.model.fpn_classifier_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fpn_classifier_graph</span></code></a>(rois, feature_maps, image_meta, ...)</p></td>
<td><p>Builds the computation graph of the feature pyramid network classifier</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.build_fpn_mask_graph" title="mrcnn.model.build_fpn_mask_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_fpn_mask_graph</span></code></a>(rois, feature_maps, image_meta, ...)</p></td>
<td><p>Builds the computation graph of the mask head of Feature Pyramid Network.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.smooth_l1_loss" title="mrcnn.model.smooth_l1_loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth_l1_loss</span></code></a>(y_true, y_pred)</p></td>
<td><p>Implements Smooth-L1 loss.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.rpn_class_loss_graph" title="mrcnn.model.rpn_class_loss_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rpn_class_loss_graph</span></code></a>(rpn_match, rpn_class_logits)</p></td>
<td><p>RPN anchor classifier loss.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.rpn_bbox_loss_graph" title="mrcnn.model.rpn_bbox_loss_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rpn_bbox_loss_graph</span></code></a>(config, target_bbox, rpn_match, ...)</p></td>
<td><p>Return the RPN bounding box loss graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.mrcnn_class_loss_graph" title="mrcnn.model.mrcnn_class_loss_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mrcnn_class_loss_graph</span></code></a>(target_class_ids, ...)</p></td>
<td><p>Loss for the classifier head of Mask RCNN.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.mrcnn_bbox_loss_graph" title="mrcnn.model.mrcnn_bbox_loss_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mrcnn_bbox_loss_graph</span></code></a>(target_bbox, target_class_ids, ...)</p></td>
<td><p>Loss for Mask R-CNN bounding box refinement.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.mrcnn_mask_loss_graph" title="mrcnn.model.mrcnn_mask_loss_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mrcnn_mask_loss_graph</span></code></a>(target_masks, target_class_ids, ...)</p></td>
<td><p>Mask binary cross-entropy loss for the masks head.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.load_image_gt" title="mrcnn.model.load_image_gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_image_gt</span></code></a>(dataset, config, image_id[, augmentation])</p></td>
<td><p>Load and return ground truth data for an image (image, mask, bounding boxes).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.build_detection_targets" title="mrcnn.model.build_detection_targets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_detection_targets</span></code></a>(rpn_rois, gt_class_ids, ...)</p></td>
<td><p>Generate targets for training Stage 2 classifier and mask heads.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.build_rpn_targets" title="mrcnn.model.build_rpn_targets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_rpn_targets</span></code></a>(image_shape, anchors, gt_class_ids, ...)</p></td>
<td><p>Given the anchors and GT boxes, compute overlaps and identify positive</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.generate_random_rois" title="mrcnn.model.generate_random_rois"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate_random_rois</span></code></a>(image_shape, count, gt_class_ids, ...)</p></td>
<td><p>Generates ROI proposals similar to what a region proposal network</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.compose_image_meta" title="mrcnn.model.compose_image_meta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose_image_meta</span></code></a>(image_id, original_image_shape, ...)</p></td>
<td><p>Takes attributes of an image and puts them in one 1D array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.parse_image_meta" title="mrcnn.model.parse_image_meta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parse_image_meta</span></code></a>(meta)</p></td>
<td><p>Parses an array that contains image attributes to its components.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.parse_image_meta_graph" title="mrcnn.model.parse_image_meta_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parse_image_meta_graph</span></code></a>(meta)</p></td>
<td><p>Parses a tensor that contains image attributes to its components.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.mold_image" title="mrcnn.model.mold_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mold_image</span></code></a>(images, config)</p></td>
<td><p>Expects an RGB image (or array of images) and subtracts</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.unmold_image" title="mrcnn.model.unmold_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmold_image</span></code></a>(normalized_images, config)</p></td>
<td><p>Takes a image normalized with mold() and returns the original.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.trim_zeros_graph" title="mrcnn.model.trim_zeros_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trim_zeros_graph</span></code></a>(boxes[, name])</p></td>
<td><p>Often boxes are represented with matrices of shape [N, 4] and</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.batch_pack_graph" title="mrcnn.model.batch_pack_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">batch_pack_graph</span></code></a>(x, counts, num_rows)</p></td>
<td><p>Picks different number of values from each row</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mrcnn.model.norm_boxes_graph" title="mrcnn.model.norm_boxes_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm_boxes_graph</span></code></a>(boxes, shape)</p></td>
<td><p>Converts boxes from pixel coordinates to normalized coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mrcnn.model.denorm_boxes_graph" title="mrcnn.model.denorm_boxes_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">denorm_boxes_graph</span></code></a>(boxes, shape)</p></td>
<td><p>Converts boxes from normalized coordinates to pixel coordinates.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.log">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.log" title="Link to this definition"></a></dt>
<dd><p>Prints a text message. And, optionally, if a Numpy array is provided it
prints it’s shape, min, and max values.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mrcnn.model.BatchNorm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">BatchNorm</span></span><a class="headerlink" href="#mrcnn.model.BatchNorm" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">tensorflow.keras.layers.BatchNormalization</span></code></p>
<p>Extends the Keras BatchNormalization class to allow a central place
to make changes if needed.</p>
<p>Batch normalization has a negative effect on training if batches are small
so this layer is often frozen (via setting in Config class) and functions
as linear layer.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.BatchNorm.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.BatchNorm.call" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Note about training values:</dt><dd><p>None: Train BN layers. This is the normal mode
False: Freeze BN layers. Good when batch size is small
True: (don’t use). Set layer in training mode even when making inferences</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.compute_backbone_shapes">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">compute_backbone_shapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.compute_backbone_shapes" title="Link to this definition"></a></dt>
<dd><p>Computes the width and height of each stage of the backbone network.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>[N, (height, width)]. Where N is the number of stages</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.identity_block">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">identity_block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_bn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.identity_block" title="Link to this definition"></a></dt>
<dd><p>The identity_block is the block that has no conv layer at shortcut
# Arguments</p>
<blockquote>
<div><p>input_tensor: input tensor
kernel_size: default 3, the kernel size of middle conv layer at main path
filters: list of integers, the nb_filters of 3 conv layer at main path
stage: integer, current stage label, used for generating layer names
block: ‘a’,’b’…, current block label, used for generating layer names
use_bias: Boolean. To use or not use a bias in conv layers.
train_bn: Boolean. Train or freeze Batch Norm layers</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.conv_block">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">conv_block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(2,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_bn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.conv_block" title="Link to this definition"></a></dt>
<dd><p>conv_block is the block that has a conv layer at shortcut
# Arguments</p>
<blockquote>
<div><p>input_tensor: input tensor
kernel_size: default 3, the kernel size of middle conv layer at main path
filters: list of integers, the nb_filters of 3 conv layer at main path
stage: integer, current stage label, used for generating layer names
block: ‘a’,’b’…, current block label, used for generating layer names
use_bias: Boolean. To use or not use a bias in conv layers.
train_bn: Boolean. Train or freeze Batch Norm layers</p>
</div></blockquote>
<p>Note that from stage 3, the first conv layer at main path is with subsample=(2,2)
And the shortcut should have subsample=(2,2) as well</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.resnet_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">resnet_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">architecture</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_bn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.resnet_graph" title="Link to this definition"></a></dt>
<dd><p>Build a ResNet graph.
architecture: Can be resnet50 or resnet101
stage5: Boolean. If False, stage5 of the network is not created
train_bn: Boolean. Train or freeze Batch Norm layers</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.apply_box_deltas_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">apply_box_deltas_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boxes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltas</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.apply_box_deltas_graph" title="Link to this definition"></a></dt>
<dd><p>Applies the given deltas to the given boxes.
boxes: [N, (y1, x1, y2, x2)] boxes to update
deltas: [N, (dy, dx, log(dh), log(dw))] refinements to apply</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.clip_boxes_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">clip_boxes_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boxes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.clip_boxes_graph" title="Link to this definition"></a></dt>
<dd><p>boxes: [N, (y1, x1, y2, x2)]
window: [4] in the form y1, x1, y2, x2</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mrcnn.model.ProposalLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">ProposalLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proposal_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nms_threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.ProposalLayer" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">tensorflow.keras.layers.Layer</span></code></p>
<p>Receives anchor scores and selects a subset to pass as proposals
to the second stage. Filtering is done based on anchor scores and
non-max suppression to remove overlaps. It also applies bounding
box refinement deltas to anchors.</p>
<dl class="simple">
<dt>Inputs:</dt><dd><p>rpn_probs: [batch, num_anchors, (bg prob, fg prob)]
rpn_bbox: [batch, num_anchors, (dy, dx, log(dh), log(dw))]
anchors: [batch, num_anchors, (y1, x1, y2, x2)] anchors in normalized coordinates</p>
</dd>
<dt>Returns:</dt><dd><p>Proposals in normalized coordinates [batch, rois, (y1, x1, y2, x2)]</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.ProposalLayer.get_config">
<span class="sig-name descname"><span class="pre">get_config</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.ProposalLayer.get_config" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.ProposalLayer.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.ProposalLayer.call" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.ProposalLayer.compute_output_shape">
<span class="sig-name descname"><span class="pre">compute_output_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.ProposalLayer.compute_output_shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.log2_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">log2_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.log2_graph" title="Link to this definition"></a></dt>
<dd><p>Implementation of Log2. TF doesn’t have a native implementation.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mrcnn.model.PyramidROIAlign">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">PyramidROIAlign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pool_shape</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.PyramidROIAlign" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">tensorflow.keras.layers.Layer</span></code></p>
<p>Implements ROI Pooling on multiple levels of the feature pyramid.</p>
<p>Params:
- pool_shape: [pool_height, pool_width] of the output pooled regions. Usually [7, 7]</p>
<p>Inputs:
- boxes: [batch, num_boxes, (y1, x1, y2, x2)] in normalized</p>
<blockquote>
<div><p>coordinates. Possibly padded with zeros if not enough
boxes to fill the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>image_meta: [batch, (meta data)] Image details. See compose_image_meta()</p></li>
<li><dl class="simple">
<dt>feature_maps: List of feature maps from different levels of the pyramid.</dt><dd><p>Each is [batch, height, width, channels]</p>
</dd>
</dl>
</li>
</ul>
<p>Output:
Pooled regions in the shape: [batch, num_boxes, pool_height, pool_width, channels].
The width and height are those specific in the pool_shape in the layer
constructor.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.PyramidROIAlign.get_config">
<span class="sig-name descname"><span class="pre">get_config</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.PyramidROIAlign.get_config" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.PyramidROIAlign.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.PyramidROIAlign.call" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.PyramidROIAlign.compute_output_shape">
<span class="sig-name descname"><span class="pre">compute_output_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.PyramidROIAlign.compute_output_shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.overlaps_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">overlaps_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boxes1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boxes2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.overlaps_graph" title="Link to this definition"></a></dt>
<dd><p>Computes IoU overlaps between two sets of boxes.
boxes1, boxes2: [N, (y1, x1, y2, x2)].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.detection_targets_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">detection_targets_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proposals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gt_class_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gt_boxes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gt_masks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.detection_targets_graph" title="Link to this definition"></a></dt>
<dd><p>Generates detection targets for one image. Subsamples proposals and
generates target class IDs, bounding box deltas, and masks for each.</p>
<p>Inputs:
proposals: [POST_NMS_ROIS_TRAINING, (y1, x1, y2, x2)] in normalized coordinates. Might</p>
<blockquote>
<div><p>be zero padded if there are not enough proposals.</p>
</div></blockquote>
<p>gt_class_ids: [MAX_GT_INSTANCES] int class IDs
gt_boxes: [MAX_GT_INSTANCES, (y1, x1, y2, x2)] in normalized coordinates.
gt_masks: [height, width, MAX_GT_INSTANCES] of boolean type.</p>
<p>Returns: Target ROIs and corresponding class IDs, bounding box shifts,
and masks.
rois: [TRAIN_ROIS_PER_IMAGE, (y1, x1, y2, x2)] in normalized coordinates
class_ids: [TRAIN_ROIS_PER_IMAGE]. Integer class IDs. Zero padded.
deltas: [TRAIN_ROIS_PER_IMAGE, (dy, dx, log(dh), log(dw))]
masks: [TRAIN_ROIS_PER_IMAGE, height, width]. Masks cropped to bbox</p>
<blockquote>
<div><p>boundaries and resized to neural network output size.</p>
</div></blockquote>
<p>Note: Returned arrays might be zero padded if not enough target ROIs.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mrcnn.model.DetectionTargetLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">DetectionTargetLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DetectionTargetLayer" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">tensorflow.keras.layers.Layer</span></code></p>
<p>Subsamples proposals and generates target box refinement, class_ids,
and masks for each.</p>
<p>Inputs:
proposals: [batch, N, (y1, x1, y2, x2)] in normalized coordinates. Might</p>
<blockquote>
<div><p>be zero padded if there are not enough proposals.</p>
</div></blockquote>
<p>gt_class_ids: [batch, MAX_GT_INSTANCES] Integer class IDs.
gt_boxes: [batch, MAX_GT_INSTANCES, (y1, x1, y2, x2)] in normalized</p>
<blockquote>
<div><p>coordinates.</p>
</div></blockquote>
<p>gt_masks: [batch, height, width, MAX_GT_INSTANCES] of boolean type</p>
<p>Returns: Target ROIs and corresponding class IDs, bounding box shifts,
and masks.
rois: [batch, TRAIN_ROIS_PER_IMAGE, (y1, x1, y2, x2)] in normalized</p>
<blockquote>
<div><p>coordinates</p>
</div></blockquote>
<p>target_class_ids: [batch, TRAIN_ROIS_PER_IMAGE]. Integer class IDs.
target_deltas: [batch, TRAIN_ROIS_PER_IMAGE, (dy, dx, log(dh), log(dw)]
target_mask: [batch, TRAIN_ROIS_PER_IMAGE, height, width]</p>
<blockquote>
<div><p>Masks cropped to bbox boundaries and resized to neural
network output size.</p>
</div></blockquote>
<p>Note: Returned arrays might be zero padded if not enough target ROIs.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.DetectionTargetLayer.get_config">
<span class="sig-name descname"><span class="pre">get_config</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DetectionTargetLayer.get_config" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.DetectionTargetLayer.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DetectionTargetLayer.call" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.DetectionTargetLayer.compute_output_shape">
<span class="sig-name descname"><span class="pre">compute_output_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DetectionTargetLayer.compute_output_shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.DetectionTargetLayer.compute_mask">
<span class="sig-name descname"><span class="pre">compute_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DetectionTargetLayer.compute_mask" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.refine_detections_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">refine_detections_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rois</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.refine_detections_graph" title="Link to this definition"></a></dt>
<dd><p>Refine classified proposals and filter overlaps and return final
detections.</p>
<dl>
<dt>Inputs:</dt><dd><p>rois: [N, (y1, x1, y2, x2)] in normalized coordinates
probs: [N, num_classes]. Class probabilities.
deltas: [N, num_classes, (dy, dx, log(dh), log(dw))]. Class-specific</p>
<blockquote>
<div><p>bounding box deltas.</p>
</div></blockquote>
<dl class="simple">
<dt>window: (y1, x1, y2, x2) in normalized coordinates. The part of the image</dt><dd><p>that contains the image excluding the padding.</p>
</dd>
</dl>
</dd>
<dt>Returns detections shaped: [num_detections, (y1, x1, y2, x2, class_id, score)] where</dt><dd><p>coordinates are normalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mrcnn.model.DetectionLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">DetectionLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DetectionLayer" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">tensorflow.keras.layers.Layer</span></code></p>
<p>Takes classified proposal boxes and their bounding box deltas and
returns the final detection boxes.</p>
<p>Returns:
[batch, num_detections, (y1, x1, y2, x2, class_id, class_score)] where
coordinates are normalized.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.DetectionLayer.get_config">
<span class="sig-name descname"><span class="pre">get_config</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DetectionLayer.get_config" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.DetectionLayer.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DetectionLayer.call" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.DetectionLayer.compute_output_shape">
<span class="sig-name descname"><span class="pre">compute_output_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DetectionLayer.compute_output_shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.rpn_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">rpn_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">feature_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anchors_per_location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anchor_stride</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.rpn_graph" title="Link to this definition"></a></dt>
<dd><p>Builds the computation graph of Region Proposal Network.</p>
<p>feature_map: backbone features [batch, height, width, depth]
anchors_per_location: number of anchors per pixel in the feature map
anchor_stride: Controls the density of anchors. Typically 1 (anchors for</p>
<blockquote>
<div><p>every pixel in the feature map), or 2 (every other pixel).</p>
</div></blockquote>
<dl>
<dt>Returns:</dt><dd><p>rpn_class_logits: [batch, H * W * anchors_per_location, 2] Anchor classifier logits (before softmax)
rpn_probs: [batch, H * W * anchors_per_location, 2] Anchor classifier probabilities.
rpn_bbox: [batch, H * W * anchors_per_location, (dy, dx, log(dh), log(dw))] Deltas to be</p>
<blockquote>
<div><p>applied to anchors.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.build_rpn_model">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">build_rpn_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">anchor_stride</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anchors_per_location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.build_rpn_model" title="Link to this definition"></a></dt>
<dd><p>Builds a Keras model of the Region Proposal Network.
It wraps the RPN graph so it can be used multiple times with shared
weights.</p>
<p>anchors_per_location: number of anchors per pixel in the feature map
anchor_stride: Controls the density of anchors. Typically 1 (anchors for</p>
<blockquote>
<div><p>every pixel in the feature map), or 2 (every other pixel).</p>
</div></blockquote>
<p>depth: Depth of the backbone feature map.</p>
<p>Returns a Keras Model object. The model outputs, when called, are:
rpn_class_logits: [batch, H * W * anchors_per_location, 2] Anchor classifier logits (before softmax)
rpn_probs: [batch, H * W * anchors_per_location, 2] Anchor classifier probabilities.
rpn_bbox: [batch, H * W * anchors_per_location, (dy, dx, log(dh), log(dw))] Deltas to be</p>
<blockquote>
<div><p>applied to anchors.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.fpn_classifier_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">fpn_classifier_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rois</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_maps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_meta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pool_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_bn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fc_layers_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1024</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.fpn_classifier_graph" title="Link to this definition"></a></dt>
<dd><p>Builds the computation graph of the feature pyramid network classifier
and regressor heads.</p>
<dl class="simple">
<dt>rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized</dt><dd><p>coordinates.</p>
</dd>
<dt>feature_maps: List of feature maps from different layers of the pyramid,</dt><dd><p>[P2, P3, P4, P5]. Each has a different resolution.</p>
</dd>
</dl>
<p>image_meta: [batch, (meta data)] Image details. See compose_image_meta()
pool_size: The width of the square feature map generated from ROI Pooling.
num_classes: number of classes, which determines the depth of the results
train_bn: Boolean. Train or freeze Batch Norm layers
fc_layers_size: Size of the 2 FC layers</p>
<dl>
<dt>Returns:</dt><dd><p>logits: [batch, num_rois, NUM_CLASSES] classifier logits (before softmax)
probs: [batch, num_rois, NUM_CLASSES] classifier probabilities
bbox_deltas: [batch, num_rois, NUM_CLASSES, (dy, dx, log(dh), log(dw))] Deltas to apply to</p>
<blockquote>
<div><p>proposal boxes</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.build_fpn_mask_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">build_fpn_mask_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rois</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_maps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_meta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pool_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_bn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.build_fpn_mask_graph" title="Link to this definition"></a></dt>
<dd><p>Builds the computation graph of the mask head of Feature Pyramid Network.</p>
<dl class="simple">
<dt>rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized</dt><dd><p>coordinates.</p>
</dd>
<dt>feature_maps: List of feature maps from different layers of the pyramid,</dt><dd><p>[P2, P3, P4, P5]. Each has a different resolution.</p>
</dd>
</dl>
<p>image_meta: [batch, (meta data)] Image details. See compose_image_meta()
pool_size: The width of the square feature map generated from ROI Pooling.
num_classes: number of classes, which determines the depth of the results
train_bn: Boolean. Train or freeze Batch Norm layers</p>
<p>Returns: Masks [batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, NUM_CLASSES]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.smooth_l1_loss">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">smooth_l1_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.smooth_l1_loss" title="Link to this definition"></a></dt>
<dd><p>Implements Smooth-L1 loss.
y_true and y_pred are typically: [N, 4], but could be any shape.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.rpn_class_loss_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">rpn_class_loss_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rpn_match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpn_class_logits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.rpn_class_loss_graph" title="Link to this definition"></a></dt>
<dd><p>RPN anchor classifier loss.</p>
<dl class="simple">
<dt>rpn_match: [batch, anchors, 1]. Anchor match type. 1=positive,</dt><dd><p>-1=negative, 0=neutral anchor.</p>
</dd>
</dl>
<p>rpn_class_logits: [batch, anchors, 2]. RPN classifier logits for BG/FG.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.rpn_bbox_loss_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">rpn_bbox_loss_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_bbox</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpn_match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpn_bbox</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.rpn_bbox_loss_graph" title="Link to this definition"></a></dt>
<dd><p>Return the RPN bounding box loss graph.</p>
<p>config: the model config object.
target_bbox: [batch, max positive anchors, (dy, dx, log(dh), log(dw))].</p>
<blockquote>
<div><p>Uses 0 padding to fill in unsed bbox deltas.</p>
</div></blockquote>
<dl class="simple">
<dt>rpn_match: [batch, anchors, 1]. Anchor match type. 1=positive,</dt><dd><p>-1=negative, 0=neutral anchor.</p>
</dd>
</dl>
<p>rpn_bbox: [batch, anchors, (dy, dx, log(dh), log(dw))]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.mrcnn_class_loss_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">mrcnn_class_loss_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_class_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_class_logits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_class_ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.mrcnn_class_loss_graph" title="Link to this definition"></a></dt>
<dd><p>Loss for the classifier head of Mask RCNN.</p>
<dl class="simple">
<dt>target_class_ids: [batch, num_rois]. Integer class IDs. Uses zero</dt><dd><p>padding to fill in the array.</p>
</dd>
</dl>
<p>pred_class_logits: [batch, num_rois, num_classes]
active_class_ids: [batch, num_classes]. Has a value of 1 for</p>
<blockquote>
<div><p>classes that are in the dataset of the image, and 0
for classes that are not in the dataset.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.mrcnn_bbox_loss_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">mrcnn_bbox_loss_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_bbox</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_class_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_bbox</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.mrcnn_bbox_loss_graph" title="Link to this definition"></a></dt>
<dd><p>Loss for Mask R-CNN bounding box refinement.</p>
<p>target_bbox: [batch, num_rois, (dy, dx, log(dh), log(dw))]
target_class_ids: [batch, num_rois]. Integer class IDs.
pred_bbox: [batch, num_rois, num_classes, (dy, dx, log(dh), log(dw))]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.mrcnn_mask_loss_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">mrcnn_mask_loss_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_masks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_class_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_masks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.mrcnn_mask_loss_graph" title="Link to this definition"></a></dt>
<dd><p>Mask binary cross-entropy loss for the masks head.</p>
<dl class="simple">
<dt>target_masks: [batch, num_rois, height, width].</dt><dd><p>A float32 tensor of values 0 or 1. Uses zero padding to fill array.</p>
</dd>
</dl>
<p>target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.
pred_masks: [batch, proposals, height, width, num_classes] float32 tensor</p>
<blockquote>
<div><p>with values from 0 to 1.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.load_image_gt">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">load_image_gt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">augmentation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.load_image_gt" title="Link to this definition"></a></dt>
<dd><p>Load and return ground truth data for an image (image, mask, bounding boxes).</p>
<dl class="simple">
<dt>augmentation: Optional. An imgaug (<a class="reference external" href="https://github.com/aleju/imgaug">https://github.com/aleju/imgaug</a>) augmentation.</dt><dd><p>For example, passing imgaug.augmenters.Fliplr(0.5) flips images
right/left 50% of the time.</p>
</dd>
</dl>
<p>Returns:
image: [height, width, 3]
shape: the original shape of the image before resizing and cropping.
class_ids: [instance_count] Integer class IDs
bbox: [instance_count, (y1, x1, y2, x2)]
mask: [height, width, instance_count]. The height and width are those</p>
<blockquote>
<div><p>of the image unless use_mini_mask is True, in which case they are
defined in MINI_MASK_SHAPE.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.build_detection_targets">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">build_detection_targets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rpn_rois</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gt_class_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gt_boxes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gt_masks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.build_detection_targets" title="Link to this definition"></a></dt>
<dd><p>Generate targets for training Stage 2 classifier and mask heads.
This is not used in normal training. It’s useful for debugging or to train
the Mask RCNN heads without using the RPN head.</p>
<p>Inputs:
rpn_rois: [N, (y1, x1, y2, x2)] proposal boxes.
gt_class_ids: [instance count] Integer class IDs
gt_boxes: [instance count, (y1, x1, y2, x2)]
gt_masks: [height, width, instance count] Ground truth masks. Can be full</p>
<blockquote>
<div><p>size or mini-masks.</p>
</div></blockquote>
<p>Returns:
rois: [TRAIN_ROIS_PER_IMAGE, (y1, x1, y2, x2)]
class_ids: [TRAIN_ROIS_PER_IMAGE]. Integer class IDs.
bboxes: [TRAIN_ROIS_PER_IMAGE, NUM_CLASSES, (y, x, log(h), log(w))]. Class-specific</p>
<blockquote>
<div><p>bbox refinements.</p>
</div></blockquote>
<dl class="simple">
<dt>masks: [TRAIN_ROIS_PER_IMAGE, height, width, NUM_CLASSES). Class specific masks cropped</dt><dd><p>to bbox boundaries and resized to neural network output size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.build_rpn_targets">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">build_rpn_targets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anchors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gt_class_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gt_boxes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.build_rpn_targets" title="Link to this definition"></a></dt>
<dd><p>Given the anchors and GT boxes, compute overlaps and identify positive
anchors and deltas to refine them to match their corresponding GT boxes.</p>
<p>anchors: [num_anchors, (y1, x1, y2, x2)]
gt_class_ids: [num_gt_boxes] Integer class IDs.
gt_boxes: [num_gt_boxes, (y1, x1, y2, x2)]</p>
<p>Returns:
rpn_match: [N] (int32) matches between anchors and GT boxes.</p>
<blockquote>
<div><p>1 = positive anchor, -1 = negative anchor, 0 = neutral</p>
</div></blockquote>
<p>rpn_bbox: [N, (dy, dx, log(dh), log(dw))] Anchor bbox deltas.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.generate_random_rois">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">generate_random_rois</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gt_class_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gt_boxes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.generate_random_rois" title="Link to this definition"></a></dt>
<dd><p>Generates ROI proposals similar to what a region proposal network
would generate.</p>
<p>image_shape: [Height, Width, Depth]
count: Number of ROIs to generate
gt_class_ids: [N] Integer ground truth class IDs
gt_boxes: [N, (y1, x1, y2, x2)] Ground truth boxes in pixels.</p>
<p>Returns: [count, (y1, x1, y2, x2)] ROI boxes in pixels.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mrcnn.model.DataGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">DataGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">augmentation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_rois</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detection_targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DataGenerator" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">tensorflow.keras.utils.Sequence</span></code></p>
<p>An iterable that returns images and corresponding target class ids,
bounding box deltas, and masks. It inherits from keras.utils.Sequence to avoid data redundancy
when multiprocessing=True.</p>
<p>dataset: The Dataset object to pick data from
config: The model config object
shuffle: If True, shuffles the samples before every epoch
augmentation: Optional. An imgaug (<a class="reference external" href="https://github.com/aleju/imgaug">https://github.com/aleju/imgaug</a>) augmentation.</p>
<blockquote>
<div><p>For example, passing imgaug.augmenters.Fliplr(0.5) flips images
right/left 50% of the time.</p>
</div></blockquote>
<dl class="simple">
<dt>random_rois: If &gt; 0 then generate proposals to be used to train the</dt><dd><p>network classifier and mask heads. Useful if training
the Mask RCNN part without the RPN.</p>
</dd>
<dt>detection_targets: If True, generate detection targets (class IDs, bbox</dt><dd><p>deltas, and masks). Typically for debugging or visualizations because
in trainig detection targets are generated by DetectionTargetLayer.</p>
</dd>
</dl>
<p>Returns a Python iterable. Upon calling __getitem__() on it, the
iterable returns two lists, inputs and outputs. The contents
of the lists differ depending on the received arguments:
inputs list:
- images: [batch, H, W, C]
- image_meta: [batch, (meta data)] Image details. See compose_image_meta()
- rpn_match: [batch, N] Integer (1=positive anchor, -1=negative, 0=neutral)
- rpn_bbox: [batch, N, (dy, dx, log(dh), log(dw))] Anchor bbox deltas.
- gt_class_ids: [batch, MAX_GT_INSTANCES] Integer class IDs
- gt_boxes: [batch, MAX_GT_INSTANCES, (y1, x1, y2, x2)]
- gt_masks: [batch, height, width, MAX_GT_INSTANCES]. The height and width</p>
<blockquote>
<div><p>are those of the image unless use_mini_mask is True, in which
case they are defined in MINI_MASK_SHAPE.</p>
</div></blockquote>
<dl class="simple">
<dt>outputs list: Usually empty in regular training. But if detection_targets</dt><dd><p>is True then the outputs list contains target class_ids, bbox deltas,
and masks.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.DataGenerator.__len__">
<span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DataGenerator.__len__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.DataGenerator.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.DataGenerator.__getitem__" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">MaskRCNN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_dir</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Encapsulates the Mask RCNN model functionality.</p>
<p>The actual Keras model is in the keras_model property.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.build" title="Link to this definition"></a></dt>
<dd><p>Build Mask R-CNN architecture.
input_shape: The shape of the input image.
mode: Either “training” or “inference”. The inputs and</p>
<blockquote>
<div><p>outputs of the model differ accordingly.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.find_last">
<span class="sig-name descname"><span class="pre">find_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.find_last" title="Link to this definition"></a></dt>
<dd><p>Finds the last checkpoint file of the last trained model in the
model directory.
Returns:</p>
<blockquote>
<div><p>The path of the last checkpoint file</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.load_weights">
<span class="sig-name descname"><span class="pre">load_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.load_weights" title="Link to this definition"></a></dt>
<dd><p>Modified version of the corresponding Keras function with
the addition of multi-GPU support and the ability to exclude
some layers from loading.
exclude: list of layer names to exclude</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.get_imagenet_weights">
<span class="sig-name descname"><span class="pre">get_imagenet_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.get_imagenet_weights" title="Link to this definition"></a></dt>
<dd><p>Downloads ImageNet trained weights from Keras.
Returns path to weights file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.compile">
<span class="sig-name descname"><span class="pre">compile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momentum</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.compile" title="Link to this definition"></a></dt>
<dd><p>Gets the model ready for training. Adds losses, regularization, and
metrics. Then calls the Keras compile() function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.set_trainable">
<span class="sig-name descname"><span class="pre">set_trainable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_regex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keras_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.set_trainable" title="Link to this definition"></a></dt>
<dd><p>Sets model layers as trainable if their names match
the given regular expression.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.set_log_dir">
<span class="sig-name descname"><span class="pre">set_log_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.set_log_dir" title="Link to this definition"></a></dt>
<dd><p>Sets the model log directory and epoch counter.</p>
<dl class="simple">
<dt>model_path: If None, or a format different from what this code uses</dt><dd><p>then set a new log directory and start epochs from 0. Otherwise,
extract the log directory and the epoch counter from the file
name.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.train">
<span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epochs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">augmentation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_callbacks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_augmentation_sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.train" title="Link to this definition"></a></dt>
<dd><p>Train the model.
train_dataset, val_dataset: Training and validation Dataset objects.
learning_rate: The learning rate to train with
epochs: Number of training epochs. Note that previous training epochs</p>
<blockquote>
<div><p>are considered to be done alreay, so this actually determines
the epochs to train in total rather than in this particaular
call.</p>
</div></blockquote>
<dl>
<dt>layers: Allows selecting wich layers to train. It can be:</dt><dd><ul class="simple">
<li><p>A regular expression to match layer names to train</p></li>
<li><p>One of these predefined values:
heads: The RPN, classifier and mask heads of the network
all: All the layers
3+: Train Resnet stage 3 and up
4+: Train Resnet stage 4 and up
5+: Train Resnet stage 5 and up</p></li>
</ul>
</dd>
<dt>augmentation: Optional. An imgaug (<a class="reference external" href="https://github.com/aleju/imgaug">https://github.com/aleju/imgaug</a>)</dt><dd><p>augmentation. For example, passing imgaug.augmenters.Fliplr(0.5)
flips images right/left 50% of the time. You can pass complex
augmentations as well. This augmentation applies 50% of the
time, and when it does it flips images right/left half the time
and adds a Gaussian blur with a random sigma in range 0 to 5.</p>
<blockquote>
<div><dl class="simple">
<dt>augmentation = imgaug.augmenters.Sometimes(0.5, [</dt><dd><p>imgaug.augmenters.Fliplr(0.5),
imgaug.augmenters.GaussianBlur(sigma=(0.0, 5.0))</p>
</dd>
</dl>
<p>])</p>
</div></blockquote>
<dl class="simple">
<dt>custom_callbacks: Optional. Add custom callbacks to be called</dt><dd><p>with the keras fit_generator method. Must be list of type keras.callbacks.</p>
</dd>
</dl>
</dd>
<dt>no_augmentation_sources: Optional. List of sources to exclude for</dt><dd><p>augmentation. A source is string that identifies a dataset and is
defined in the Dataset class.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.mold_inputs">
<span class="sig-name descname"><span class="pre">mold_inputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.mold_inputs" title="Link to this definition"></a></dt>
<dd><p>Takes a list of images and modifies them to the format expected
as an input to the neural network.
images: List of image matrices [height,width,depth]. Images can have</p>
<blockquote>
<div><p>different sizes.</p>
</div></blockquote>
<p>Returns 3 Numpy matrices:
molded_images: [N, h, w, 3]. Images resized and normalized.
image_metas: [N, length of meta data]. Details about each image.
windows: [N, (y1, x1, y2, x2)]. The portion of the image that has the</p>
<blockquote>
<div><p>original image (padding excluded).</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.unmold_detections">
<span class="sig-name descname"><span class="pre">unmold_detections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">detections</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mrcnn_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">original_image_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.unmold_detections" title="Link to this definition"></a></dt>
<dd><p>Reformats the detections of one image from the format of the neural
network output to a format suitable for use in the rest of the
application.</p>
<p>detections: [N, (y1, x1, y2, x2, class_id, score)] in normalized coordinates
mrcnn_mask: [N, height, width, num_classes]
original_image_shape: [H, W, C] Original image shape before resizing
image_shape: [H, W, C] Shape of the image after resizing and padding
window: [y1, x1, y2, x2] Pixel coordinates of box in the image where the real</p>
<blockquote>
<div><p>image is excluding the padding.</p>
</div></blockquote>
<p>Returns:
boxes: [N, (y1, x1, y2, x2)] Bounding boxes in pixels
class_ids: [N] Integer class IDs for each bounding box
scores: [N] Float probability scores of the class_id
masks: [height, width, num_instances] Instance masks</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.detect">
<span class="sig-name descname"><span class="pre">detect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.detect" title="Link to this definition"></a></dt>
<dd><p>Runs the detection pipeline.</p>
<p>images: List of images, potentially of different sizes.</p>
<p>Returns a list of dicts, one dict per image. The dict contains:
rois: [N, (y1, x1, y2, x2)] detection bounding boxes
class_ids: [N] int class IDs
scores: [N] float probability scores for the class IDs
masks: [H, W, N] instance binary masks</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.detect_molded">
<span class="sig-name descname"><span class="pre">detect_molded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molded_images</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_metas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.detect_molded" title="Link to this definition"></a></dt>
<dd><p>Runs the detection pipeline, but expect inputs that are
molded already. Used mostly for debugging and inspecting
the model.</p>
<p>molded_images: List of images loaded using load_image_gt()
image_metas: image meta data, also returned by load_image_gt()</p>
<p>Returns a list of dicts, one dict per image. The dict contains:
rois: [N, (y1, x1, y2, x2)] detection bounding boxes
class_ids: [N] int class IDs
scores: [N] float probability scores for the class IDs
masks: [H, W, N] instance binary masks</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.get_anchors">
<span class="sig-name descname"><span class="pre">get_anchors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.get_anchors" title="Link to this definition"></a></dt>
<dd><p>Returns anchor pyramid for the given image size.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.ancestor">
<span class="sig-name descname"><span class="pre">ancestor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checked</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.ancestor" title="Link to this definition"></a></dt>
<dd><p>Finds the ancestor of a TF tensor in the computation graph.
tensor: TensorFlow symbolic tensor.
name: Name of ancestor tensor to find
checked: For internal use. A list of tensors that were already</p>
<blockquote>
<div><p>searched to avoid loops in traversing the graph.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.find_trainable_layer">
<span class="sig-name descname"><span class="pre">find_trainable_layer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.find_trainable_layer" title="Link to this definition"></a></dt>
<dd><p>If a layer is encapsulated by another layer, this function
digs through the encapsulation and returns the layer that holds
the weights.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.get_trainable_layers">
<span class="sig-name descname"><span class="pre">get_trainable_layers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.get_trainable_layers" title="Link to this definition"></a></dt>
<dd><p>Returns a list of layers that have weights.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mrcnn.model.MaskRCNN.run_graph">
<span class="sig-name descname"><span class="pre">run_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_metas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.MaskRCNN.run_graph" title="Link to this definition"></a></dt>
<dd><p>Runs a sub-set of the computation graph that computes the given
outputs.</p>
<dl class="simple">
<dt>image_metas: If provided, the images are assumed to be already</dt><dd><p>molded (i.e. resized, padded, and normalized)</p>
</dd>
<dt>outputs: List of tuples (name, tensor) to compute. The tensors are</dt><dd><p>symbolic TensorFlow tensors and the names are for easy tracking.</p>
</dd>
</dl>
<p>Returns an ordered dict of results. Keys are the names received in the
input and values are Numpy arrays.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.compose_image_meta">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">compose_image_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">original_image_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_class_ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.compose_image_meta" title="Link to this definition"></a></dt>
<dd><p>Takes attributes of an image and puts them in one 1D array.</p>
<p>image_id: An int ID of the image. Useful for debugging.
original_image_shape: [H, W, C] before resizing or padding.
image_shape: [H, W, C] after resizing and padding
window: (y1, x1, y2, x2) in pixels. The area of the image where the real</p>
<blockquote>
<div><p>image is (excluding the padding)</p>
</div></blockquote>
<p>scale: The scaling factor applied to the original image (float32)
active_class_ids: List of class_ids available in the dataset from which</p>
<blockquote>
<div><p>the image came. Useful if training on images from multiple datasets
where not all classes are present in all datasets.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.parse_image_meta">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">parse_image_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">meta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.parse_image_meta" title="Link to this definition"></a></dt>
<dd><p>Parses an array that contains image attributes to its components.
See compose_image_meta() for more details.</p>
<p>meta: [batch, meta length] where meta length depends on NUM_CLASSES</p>
<p>Returns a dict of the parsed values.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.parse_image_meta_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">parse_image_meta_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">meta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.parse_image_meta_graph" title="Link to this definition"></a></dt>
<dd><p>Parses a tensor that contains image attributes to its components.
See compose_image_meta() for more details.</p>
<p>meta: [batch, meta length] where meta length depends on NUM_CLASSES</p>
<p>Returns a dict of the parsed tensors.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.mold_image">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">mold_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.mold_image" title="Link to this definition"></a></dt>
<dd><p>Expects an RGB image (or array of images) and subtracts
the mean pixel and converts it to float. Expects image
colors in RGB order.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.unmold_image">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">unmold_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalized_images</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.unmold_image" title="Link to this definition"></a></dt>
<dd><p>Takes a image normalized with mold() and returns the original.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.trim_zeros_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">trim_zeros_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boxes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trim_zeros'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.trim_zeros_graph" title="Link to this definition"></a></dt>
<dd><p>Often boxes are represented with matrices of shape [N, 4] and
are padded with zeros. This removes zero boxes.</p>
<p>boxes: [N, 4] matrix of boxes.
non_zeros: [N] a 1D boolean mask identifying the rows to keep</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.batch_pack_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">batch_pack_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_rows</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.batch_pack_graph" title="Link to this definition"></a></dt>
<dd><p>Picks different number of values from each row
in x depending on the values in counts.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.norm_boxes_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">norm_boxes_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boxes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.norm_boxes_graph" title="Link to this definition"></a></dt>
<dd><p>Converts boxes from pixel coordinates to normalized coordinates.
boxes: […, (y1, x1, y2, x2)] in pixel coordinates
shape: […, (height, width)] in pixels</p>
<p>Note: In pixel coordinates (y2, x2) is outside the box. But in normalized
coordinates it’s inside the box.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>[…, (y1, x1, y2, x2)] in normalized coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mrcnn.model.denorm_boxes_graph">
<span class="sig-prename descclassname"><span class="pre">mrcnn.model.</span></span><span class="sig-name descname"><span class="pre">denorm_boxes_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boxes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mrcnn.model.denorm_boxes_graph" title="Link to this definition"></a></dt>
<dd><p>Converts boxes from normalized coordinates to pixel coordinates.
boxes: […, (y1, x1, y2, x2)] in normalized coordinates
shape: […, (height, width)] in pixels</p>
<p>Note: In pixel coordinates (y2, x2) is outside the box. But in normalized
coordinates it’s inside the box.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>[…, (y1, x1, y2, x2)] in pixel coordinates</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Tom Soulaire.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>